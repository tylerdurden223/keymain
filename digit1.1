
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Shovels = {}
local OriginalShovelNames = {}

local function AddComma(amount: number)
	local formatted = amount
	local k
	while true do
		formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
		if (k==0) then
			break
		end
	end
	return formatted
end

for i,v in ReplicatedStorage.Settings.Items.Shovels:GetChildren() do
	local Success, ItemInfo = pcall(require, v)

	local BuyPrice = 0
	
	local NewName

	if Success and ItemInfo then
		if not ItemInfo.BuyPrice then
			continue
		end
		
		BuyPrice = ItemInfo.BuyPrice
		
		NewName = `{v.Name} (${AddComma(BuyPrice)})`
	else
		NewName = `{v.Name} (Can't See Price)`
	end
	
	table.insert(Shovels, NewName)
	OriginalShovelNames[NewName] = {
		Name = v.Name,
		BuyPrice = BuyPrice
	}
end

local Enchantments = {"Your executor does not support this."}

local Success, EnchantModule = pcall(require, ReplicatedStorage.Settings.Enchantments)

if Success then
	table.remove(Enchantments, 1)
	
	for Enchant, Info in EnchantModule.EnchantmentsList do
		for Tier, _ in Info.Tiers do
			table.insert(Enchantments, `{Enchant} {Tier}`)
		end
	end
	
	table.sort(Enchantments)
end

table.sort(Shovels, function(a,b)
	return OriginalShovelNames[a].BuyPrice < OriginalShovelNames[b].BuyPrice
end)


local CollectionService = game:GetService("CollectionService")

local Player = game:GetService("Players").LocalPlayer

local Network = ReplicatedStorage:WaitForChild("Source"):WaitForChild("Network")
local RemoteFunctions: {[string]: RemoteFunction} = Network:WaitForChild("RemoteFunctions")
local RemoteEvents: {[string]: RemoteEvent} = Network:WaitForChild("RemoteEvents")



local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local Window = Fluent:CreateWindow({
    Title = "NEOX HUB | Dig It | SIMPLE VERSION v1.1",
    SubTitle = "by hassanxzayn",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})



local Tabs = {
    Home = Window:AddTab({ Title = "| Home", Icon = "rbxassetid://7733960981" }),
    Main = Window:AddTab({ Title = "| Main", Icon = "rbxassetid://7743869612" }),
    Misc = Window:AddTab({ Title = "| Misc", Icon = "rbxassetid://7733789088" }),
    Shop = Window:AddTab({ Title = "| Shop", Icon = "rbxassetid://7734056747" }),
    Teleport = Window:AddTab({ Title = "| Teleport", Icon = "rbxassetid://7733992789" }),
}



Window:SelectTab(1)


Tabs.Home:AddButton({
    Title = "Join our discord",
    Description = "Click on this button to copy the invite link!",
    Callback = function()
        local inviteLink = "https://discord.gg/99UuEwM9sX"
        
        if setclipboard then
            setclipboard(inviteLink)
            print("bro coming to our discord yay!")
        else
            print("setclipboard function not available")
        end
    end
})






local Islands = {}

for i,v in workspace.Map.Islands:GetChildren() do
    table.insert(Islands, v.Name)
end

for i,v in ReplicatedStorage.Assets.Sounds.Soundtrack.Locations:GetChildren() do
    if v.Name == "Ocean" then
        continue
    end

    if not table.find(Islands, v.Name) then
        table.insert(Islands, v.Name)
    end
end

table.sort(Islands)

local Dropdown = Tabs.Teleport:AddDropdown("Dropdown", {
    Title = "Teleport to Island",
    Description = "",
    Values = Islands,
    Multi = false,
    Default = nil,
    Callback = function(CurrentOption)
        if CurrentOption == "" then
            return
        end
        
        local Island = workspace.Map.Islands:FindFirstChild(CurrentOption)

        if not Island then
            return Notify("Error", "That island doesn't currently exist.")
        end

        if Island:FindFirstChild("LocationSpawn") then
            Player.Character:PivotTo(Island.LocationSpawn.CFrame)
        elseif Island:FindFirstChild("SpawnPoint") then
            Player.Character:PivotTo(Island.SpawnPoint.CFrame)
        elseif CurrentOption ~= "Badlands" then
            Player.Character:PivotTo(Island:GetAttribute("Pivot"))
        else
            Player.Character:PivotTo(Island:GetAttribute("Pivot") + Vector3.yAxis * Island:GetAttribute("Size") / 2)
        end
    end
})




-- Initialize Flags
local Flags = {
    Sell = {
        CurrentValue = true -- Default value; can be toggled as needed.
    }
}

-- Function to get inventory size
local function GetInventorySize()
    local Inventory: {[string]: {["Attributes"]: {["Weight"]: number}}} = RemoteFunctions.Player:InvokeServer({
        Command = "GetInventory"
    })

    local InventorySize = 0

    for ID, Object in Inventory do
        InventorySize += 1
    end

    return InventorySize
end

-- Function to sell inventory
local function SellInventory()
    -- Prevent the character from falling down during the process
    Player.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    
    -- Find the nearest merchant
    local Merchant: Model
    for _, v: TextLabel in workspace.Map.Islands:GetDescendants() do
        if v.Name ~= "Title" or not v:IsA("TextLabel") or v.Text ~= "Merchant" then
            continue
        end
        Merchant = v.Parent.Parent
        break
    end

    -- If no merchant is found, exit the function
    if not Merchant then
        warn("No merchant found in the map.")
        return
    end

    -- Store initial values
    local SellEnabled = Flags.Sell.CurrentValue
    local PreviousPosition = Player.Character:GetPivot()
    local PreviousSize = GetInventorySize()

    local Teleported = false
    local StartTime = tick()

    -- Repeat the selling process until inventory size changes or timeout
    repeat
        Player.Character:PivotTo(Merchant:GetPivot())

        RemoteEvents.Merchant:FireServer({
            Command = "SellAllTreasures",
            Merchant = Merchant
        })

        task.wait(0.1)
        Teleported = true
    until GetInventorySize() ~= PreviousSize or Flags.Sell.CurrentValue ~= SellEnabled or tick() - StartTime >= 3

    -- Return the character to its previous position
    if Teleported then
        Player.Character:PivotTo(PreviousPosition)
    end
end

-- Adding the button to the Fluent UI
Tabs.Misc:AddButton({
    Title = "Quick Sell Inventory",
    Description = "",
    Callback = SellInventory
})



local Flags = Flags or {}  -- Ensure Flags is initialized
Flags.Sell = Flags.Sell or { CurrentValue = false }  -- Ensure the 'Sell' flag is initialized

local Toggle = Tabs.Misc:AddToggle("MyToggle", {
    Title = "Auto Sell Inventory (When Backpack Full)",
    Description = "",
    Default = false,
    Callback = function(Value)
        -- Update the flag value based on the toggle state
        Flags.Sell.CurrentValue = Value

        local function GetInventorySize()
            local Inventory: {[string]: {["Attributes"]: {["Weight"]: number}}} = RemoteFunctions.Player:InvokeServer({
                Command = "GetInventory"
            })

            local InventorySize = 0

            for ID, Object in Inventory do
                InventorySize += 1
            end

            return InventorySize
        end

        local function SellInventory()
            Player.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
            
            local Merchant: Model

            for _,v: TextLabel in workspace.Map.Islands:GetDescendants() do
                if v.Name ~= "Title" or not v:IsA("TextLabel") or v.Text ~= "Merchant" then
                    continue
                end

                Merchant = v.Parent.Parent
                break
            end
            
            local SellEnabled = Flags.Sell.CurrentValue
            local PreviousPosition = Player.Character:GetPivot()
            local PreviousSize = GetInventorySize()
            
            local Teleported = false
            
            local StartTime = tick()
            
            repeat
                Player.Character:PivotTo(Merchant:GetPivot())

                RemoteEvents.Merchant:FireServer({
                    Command = "SellAllTreasures",
                    Merchant = Merchant
                })

                task.wait(0.1)
                Teleported = true
            until GetInventorySize() ~= PreviousSize or Flags.Sell.CurrentValue ~= SellEnabled or tick() - StartTime >= 3
            
            if Teleported then
                Player.Character:PivotTo(PreviousPosition)
            end
        end

        while Flags.Sell.CurrentValue and task.wait() do
            if GetInventorySize() < Player:GetAttribute("MaxInventorySize") + 9 then
                print("InventorySize:", GetInventorySize(), "Max:", Player:GetAttribute("MaxInventorySize") + 9)
                continue
            end

            SellInventory()
        end
    end
})



local Dropdown = Tabs.Shop:AddDropdown("Purchase Shovel", { 
    Title = "Purchase Shovel",
    Description = "",
    Values = Shovels, -- Use the `Shovels` table directly
    Multi = false, -- Single option only
    Default = nil, -- Default to None (no pre-selected option)
    Callback = function(CurrentOption)
        if not CurrentOption or CurrentOption == "" then
            return -- Do nothing if no valid option is selected
        end

        -- Invoke the server with the selected shovel's information
        RemoteFunctions.Shop:InvokeServer({
            Command = "Buy",
            Type = "Item",
            Product = OriginalShovelNames[CurrentOption].Name,
            Amount = 1
        })

        -- Resetting the dropdown to None isn't directly supported in Fluent.
        -- Workaround: Clear user context or provide feedback as needed.
    end,
})


-- Adding the "Quick Appraise Held Item" button to the Fluent UI
Tabs.Misc:AddButton({
    Title = `Quick Appraise Held Item [${RemoteFunctions.LootPit:InvokeServer({Command = "GetPlayerPrice"})}]`,
    Description = "",
    Callback = function()
        RemoteFunctions.LootPit:InvokeServer({
            Command = "AppraiseItem"
        })
    end
})


local CollectedRewards = {}

-- Define Flags for your toggle
local Flags = {
    Salary = { CurrentValue = false }
}

local Toggle = Tabs.Misc:AddToggle("MyToggle", {
    Title = "Auto Collect Salary Rewards",
    Description = "It Will Appear As Unclaimed",
    Default = false,
    Callback = function(Value)
        -- Update Flags when toggle changes
        Flags.Salary.CurrentValue = Value
        
        while Flags.Salary.CurrentValue and task.wait() do
            local TierTimers = RemoteFunctions.TimeRewards:InvokeServer({
                Command = "GetSessionTimers"
            })

            for Tier, Timer in TierTimers do
                if Timer ~= 0 then
                    CollectedRewards[Tier] = false
                    continue
                end

                if CollectedRewards[Tier] then
                    continue
                end

                RemoteFunctions.TimeRewards:InvokeServer({
                    Command = "RedeemTier",
                    Tier = Tier
                })

                CollectedRewards[Tier] = true
            end

            task.wait(5)
        end
    end
})







local HideGui = false  -- Set initial state to false (UI is visible)

local Toggle = Tabs.Misc:AddToggle("MyToggle",  
{
    Title = "Hide/Show UIs", 
    Description = "",
    Default = false,  -- Default state of the toggle is false
    Callback = function(newState)
        HideGui = newState  -- Set HideGui to the toggle state (true or false)

        -- Toggle the visibility of the UIs based on HideGui state
        for _, gui in pairs(game.Players.LocalPlayer.PlayerGui:GetChildren()) do
            if gui:IsA("ScreenGui") then
                gui.Enabled = not HideGui  -- If HideGui is true, hide the UI, else show it
            end
        end
    end
})

-- Ensure the UI is visible initially (based on the HideGui state)
for _, gui in pairs(game.Players.LocalPlayer.PlayerGui:GetChildren()) do
    if gui:IsA("ScreenGui") then
        gui.Enabled = not HideGui  -- Show the UI if HideGui is false (default)
    end
end



local Toggle = Tabs.Misc:AddToggle("MyToggle", 
{
    Title = "Freeze Character", 
    Description = "",
    Default = false,
    Callback = function(state)
        local player = game:GetService("Players").LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if state then
                player.Character.HumanoidRootPart.Anchored = true
                print("bro saw baddie and bro got Shocked.")
            else
                player.Character.HumanoidRootPart.Anchored = false
                print("bro saw ugly ass and start moving.")
            end
        else
            warn("Player or HumanoidRootPart not found!")
        end
    end
})

Tabs.Main:AddParagraph({
    Title = "Important",
    Content = "This is SIMPLE version 1.1. Version 1.2 will be an advanced update with more functionsâ€”stay tuned"
})


Tabs.Misc:AddButton({
    Title = "Anti AFK",
    Description = "",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/hassanxzayn-lua/Anti-afk/main/antiafkbyhassanxzyn"))();
	end
})




local DisableSwimmingToggle = Tabs.Misc:AddToggle("DisableSwimmingToggle", 
{
    Title = "Disable Swimming", 
    Description = "",
    Default = false,
    Callback = function(state)
        local LocalPlayer = game.Players.LocalPlayer
        local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

        if LocalCharacter and LocalCharacter:FindFirstChild("Humanoid") then
            local Humanoid = LocalCharacter:FindFirstChild("Humanoid")
            if Humanoid then
                if state then
                    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
                    print("bro why you stop swimming")
                else
                    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true)
                    print("bro start swimming")
                end
            end
        else
            warn("Humanoid not found!")
        end
    end
})





local BlackGui = Instance.new("ScreenGui")
BlackGui.Name = "BlackGui"
BlackGui.ResetOnSpawn = false
local blackFrame = Instance.new("Frame")
blackFrame.Name = "BlackFrame"
blackFrame.Size = UDim2.new(1, 0, 1, 0)
blackFrame.BackgroundColor3 = Color3.new(0, 0, 0)
blackFrame.BackgroundTransparency = 1
blackFrame.Parent = BlackGui
BlackGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local WhiteGui = Instance.new("ScreenGui")
WhiteGui.Name = "WhiteGui"
WhiteGui.ResetOnSpawn = false
local whiteFrame = Instance.new("Frame")
whiteFrame.Name = "WhiteFrame"
whiteFrame.Size = UDim2.new(1, 0, 1, 0)
whiteFrame.BackgroundColor3 = Color3.new(1, 1, 1)
whiteFrame.BackgroundTransparency = 1
whiteFrame.Parent = WhiteGui
WhiteGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local BlackGui5 = Tabs.Misc:AddToggle("BlackGui5", {Title = "Black Screen", Default = false })
BlackGui5:OnChanged(function()
    local Black123 = BlackGui5.Value
    if Black123 then
        blackFrame.BackgroundTransparency = 0
    else
        blackFrame.BackgroundTransparency = 1
    end
end)

local WhiteGui5 = Tabs.Misc:AddToggle("WhiteGui5", {Title = "White Screen", Default = false })
WhiteGui5:OnChanged(function()
    local White123 = WhiteGui5.Value
    if White123 then
        whiteFrame.BackgroundTransparency = 0 
    else
        whiteFrame.BackgroundTransparency = 1
    end
end)


Tabs.Misc:AddButton({
    Title = "Infiniteyield Reborn",
    Description = "",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/RyXeleron/infiniteyield-reborn/refs/heads/scriptblox/source"))()
    end
})




local Section = Tabs.Misc:AddSection("Character")



local TeleportToggle = Tabs.Misc:AddToggle("TeleportToggle", 
{
    Title = "T + Left Click Teleport", 
    Description = "",
    Default = false,
    Callback = function(Value)
        if not hasUserToggled and not isTeleportEnabled then
            hasUserToggled = true
            isTeleportEnabled = Value
            return
        end

        isTeleportEnabled = Value
        if Value then
            if not connection then
                connection = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
                    if not gameProcessed and isTeleportEnabled and input.UserInputType == Enum.UserInputType.MouseButton1 then
                        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.T) then
                            local player = game:GetService("Players").LocalPlayer
                            local mouse = player:GetMouse()
                            player.Character:MoveTo(Vector3.new(mouse.Hit.x, mouse.Hit.y, mouse.Hit.z))
                        end
                    end
                end)
            end
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end
})


local InfiniteJumpToggle = Tabs.Misc:AddToggle("InfiniteJumpToggle", 
{
    Title = "Infinite Jumps", 
    Description = "",
    Default = false,
    Callback = function(Value)
        _G.infinjump = Value
    end
})

if not _G.infinJumpStarted then
    _G.infinJumpStarted = true
    _G.infinjump = false

    local plr = game:GetService('Players').LocalPlayer
    local m = plr:GetMouse()

    m.KeyDown:Connect(function(key)
        if _G.infinjump then
            if key:byte() == 32 then
                local humanoid = plr.Character and plr.Character:FindFirstChildOfClass('Humanoid')
                if humanoid then
                    humanoid:ChangeState('Jumping')
                    wait()
                    humanoid:ChangeState('Seated')
                end
            end
        end
    end)
end



local Noclip = nil
local Clip = true

function noclip()
	Clip = false
	local function Nocl()
		if Clip == false and game.Players.LocalPlayer.Character ~= nil then
			for _, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
				if v:IsA('BasePart') and v.CanCollide and v.Name ~= floatName then
					v.CanCollide = false
				end
			end
		end
		wait(0.21)
	end
	Noclip = game:GetService('RunService').Stepped:Connect(Nocl)
end

function clip()
	if Noclip then 
		Noclip:Disconnect()
	end
	Clip = true
	if game.Players.LocalPlayer.Character then
		for _, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
			if v:IsA('BasePart') and v.CanCollide == false then
				v.CanCollide = true
			end
		end
	end
end

local Toggle = Tabs.Misc:AddToggle("MyToggle", {
    Title = "Noclip",
    Description = "",
    Default = false,
    Callback = function(state)
        if state then
            noclip()
        else
            clip()
        end
    end
})




local Slider = Tabs.Misc:AddSlider("SpeedSlider", 
{
    Title = "WalkSpeed",
    Description = "",
    Default = 16,
    Min = 16,
    Max = 500,
    Rounding = 1,
    Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
    end
})

local Slider = Tabs.Misc:AddSlider("JumpSlider", 
{
    Title = "Jump Power",
    Description = "",
    Default = 50,
    Min = 50,
    Max = 500,
    Rounding = 1,
    Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
    end
})

local runService = game:GetService("RunService")
local event

local Slider = Tabs.Misc:AddSlider("GravitySlider", 
{
    Title = "Gravity",
    Description = "",
    Default = 196,
    Min = 0,
    Max = 500,
    Rounding = 1,
    Callback = function(Value)
        print("Gravity slider changed to:", Value)
        if event then
            event:Disconnect()
        end
        event = runService.RenderStepped:Connect(function()
            workspace.Gravity = Value
        end)
    end
})

local Slider = Tabs.Misc:AddSlider("AssSlider", 
{
    Title = "HipHeight",
    Description = "",
    Default = 0,
    Min = 0,
    Max = 500,
    Rounding = 1,
    Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.HipHeight = Value
    end
})



local Input = Tabs.Misc:AddInput("FOVInput", 
{
    Title = "Change FOV",
    Description = "",
    Default = "70",
    Placeholder = "Enter FOV value",
    Numeric = true,
    Finished = true,
    Callback = function(Value)
        local fov = tonumber(Value)
        if fov then
            game.Workspace.Camera.FieldOfView = fov
            print("FOV set to:", fov)
        else
            warn("Invalid FOV value entered")
        end
    end
})










-- Ensure Flags is initialized if not already done
Flags = Flags or {}

-- Initialize the specific flags with default values
Flags.CreatePiles = Flags.CreatePiles or { CurrentValue = false }
Flags.LegitPiles = Flags.LegitPiles or { CurrentValue = false }

-- Auto Create Piles on Any Terrain Toggle
local CreatePilesToggle = Tabs.Main:AddToggle("CreatePilesToggle", {
    Title = "Auto Create Piles on Any Terrain",
    Description = "",
    Default = false,
    Callback = function(Value)    
        Flags.CreatePiles.CurrentValue = Value  -- Update the flag when the toggle is used
        while Flags.CreatePiles.CurrentValue and task.wait() do    
            if Player:GetAttribute("PileCount") ~= 0 then
                continue
            end
            
            local PileInfo: {["PileIndex"]: number, ["Success"]: boolean} = RemoteFunctions.Digging:InvokeServer({
                Command = "CreatePile"
            })
            
            if PileInfo.Success then
                RemoteEvents.Digging:FireServer({
                    Command = "DigIntoSandSound"
                })
            end
        end
    end
})

-- Auto Legit Create Piles Toggle (Needed for Legit Dig)
local LegitPilesToggle = Tabs.Main:AddToggle("LegitPilesToggle", {
    Title = "Auto Create Piles",
    Description = "",
    Default = false,
    Callback = function(Value)    
        Flags.LegitPiles.CurrentValue = Value  -- Update the flag when the toggle is used
        while Flags.LegitPiles.CurrentValue and task.wait() do
            local Tool = Player.Character:FindFirstChildOfClass("Tool")
            
            if not Tool or Tool:GetAttribute("Type") ~= "Shovel" then
                continue
            end
            
            local PileAdornee: Model? = Player.Character.Shovel.Highlight.Adornee

            if PileAdornee and PileAdornee:GetAttribute("Blacklisted") then
                continue
            end
            
            Tool:Activate()
        end
    end
})





local Flags = Flags or {}  -- Ensure Flags is initialized
Flags.LegitDig = Flags.LegitDig or { CurrentValue = false }  -- Initialize LegitDig flag

local Toggle = Tabs.Main:AddToggle("DigToggle", {
    Title = "Auto Fast Dig",
    Description = "",
    Default = false,
    Callback = function(Value)
        -- Auto Fast Dig Logic
        while Value and task.wait() do
            if not Player.Character:FindFirstChildOfClass("Tool") then
                continue
            end

            local Adornee: Model? = Player.Character.Shovel.Highlight.Adornee

            if not Adornee or Adornee.Parent ~= workspace.Map.TreasurePiles or Adornee:GetAttribute("Blacklisted") then
                continue
            end

            RemoteFunctions.Digging:InvokeServer({
                Command = "DigPile",
                TargetPileIndex = Adornee:GetAttribute("PileIndex")
            })
        end
    end
})

-- Auto Legit Dig Logic (100% Success Rate)
local function LegitDig()
    if not Flags.LegitDig.CurrentValue then
        return
    end

    local DigMinigame = Player.PlayerGui.Main:FindFirstChild("DigMinigame")

    if not DigMinigame then
        return
    end

    local Connection: RBXScriptConnection
    Connection = game:GetService("RunService").Heartbeat:Connect(function()
        local DigMinigame = Player.PlayerGui.Main:FindFirstChild("DigMinigame")

        if not DigMinigame or not Flags.LegitDig.CurrentValue then
            return Connection:Disconnect()
        end

        DigMinigame.Cursor.Position = DigMinigame.Area.Position
    end)

    HandleConnection(Connection, "LegitDigHeartbeat")
end

-- Create Legit Dig toggle
Tabs.Main:AddToggle("LegitDigToggle", {
    Title = "Auto Dig",
    Description = "",
    Default = false,
    Callback = function(Value)
        Flags.LegitDig.CurrentValue = Value  -- Update the flag when the toggle is used
        if Value then
            LegitDig()
        end
    end
})

-- Trigger Legit Dig when the DigMinigame is added to the player's UI
HandleConnection(Player.PlayerGui.Main.ChildAdded:Connect(LegitDig), "LegitDig")


